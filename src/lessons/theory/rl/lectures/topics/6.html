<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1">
		<link rel="stylesheet" type="text/css" href="../../../css/page.css">
		<link rel="stylesheet" type="text/css" href="../../../css/katex.css">
		<title></title>
	</head>
	<body>
		<div class="page">
			<div class="sidebar">
				<a id="nextPage">
					<img src="../../../css/icons/forward.svg" title="Далее">
				</a>
				<a id="prevPage">
					<img src="../../../css/icons/backward.svg" title="Назад">
				</a>
				<a href="index.html">
					<img src="../../../css/icons/submenu.svg" title="Подменю">
				</a>
				<a href="../../../index.html">
					<img src="../../../css/icons/menu.svg" title="Главное меню">
				</a>
				<a href="https://t.me/quessentry">
					<img src="../../../css/icons/tg.svg" class="icon" title="Связь со мной">
				</a>
			</div>
			<div class="elements">
				<div class="topic">
					<div class="num">
						<p>06</p>
					</div>
					<div class="title">
						<p>Аппроксимация функции полезности. Линейный подход. Целевая функция (функционал ошибки)</p>
					</div>
				</div>
				<div class="content">
					<p class="redline">В задачах с большими или непрерывными пространствами состояний (cостояния описываются вещественными числами и могут принимать бесконечное число значений, например,  координаты робота в пространстве, его скорость и ускорение) точное вычисление функции полезности становится невозможным из-за вычислительной сложности. В таких случаях используется аппроксимация функции полезности посредством базисных функций. Базисные функции позволяют:</p>
					<ul>
						<li>уменьшить размерность задачи, преобразуя непрерывное пространство состояний в конечное пространство признаков;</li>
						<li>упростить вычисления, так как вместо работы с бесконечным пространством состояний работа ведется с конечным числом признаков;</li>
						<li>обеспечить обобщение, так как похожие состояния будут иметь схожие признаки.</li>
					</ul>
					<p>Линейный подход предполагает, что функция полезности может быть представлена как линейная комбинация некоторых заранее заданных базисных функций (features). Пусть:</p>
					<ul class="property">
						<li>$s$ — состояние агента;</li>
						<li>$\phi(s) = [\phi_1(s), \phi_2(s), ..., \phi_n(s)]^T$ — вектор базисных функций, которые преобразуют состояние $s$ в $n$-мерный вектор признаков;</li>
						<li>$\mathbf{w} = [w_1, w_2, ..., w_n]^T$ — вектор весов модели.</li>
					</ul>
					<p>Тогда аппроксимированная функция полезности $V(s)$ может быть записана как:</p>
					<p class="equation">$V(s, \mathbf{w}) = \mathbf{w}^T\phi(s)=\sum_{i=1}^n \mathbf{w}_i \phi_i(s)$.</p>
					<p>Здесь $V(s,\mathbf{w})$ — это линейная комбинация базисных функций с весами $\mathbf{w}$.</p>
					<p class="sign">Целевая функция (функционал ошибки)</p>
					<p>Цель обучения: найти такие веса $\mathbf{w}$, чтобы аппроксимированная функция полезности $V(s,\mathbf{w})$ была как можно ближе к истинной функции полезности $V^{\pi}(s)$.</p>
					<p>В качестве функционала качества обычно используют MSE:</p>
					<p class="equation">$J(\mathbf{w})=\mathbb{E}_{s \sim d^{\pi}}\bigg[(V^{\pi}(s)-V(s, \mathbf{w}))^2\bigg]$,</p>
					<p>где $\mathbb{E}_{s \sim d^{\pi}}$ — математическое ожидание по состояниям, распределенным согласно стационарному распределению $d^{\pi}$, индуцированному политикой $\pi$.</p>
					<p>Математическое ожидание позволяет учесть вклад каждого состояния в соответствии с его вероятностью, что обеспечивает глобальную оптимизацию функционала качества. Стационарное распределение $d^{\pi}$ отражает долгосрочное поведение агента при следовании политике $\pi$. "Индуцированное политикой $\pi$ означает, что распределение $d^{\pi}$ зависит от того, как агент выбирает действия согласно $\pi$.</p>
					<p>Для минимизации целевой функции $J(\mathbf{w})$ используется метод градиентного спуска. Обновление весов $\mathbf{w}$ выполняется по правилу:</p>
					<p class="equation">$\mathbf{w} \leftarrow \mathbf{w} + \frac{1}{2} \alpha \nabla_{\mathbf{w}}J(\mathbf{w}), \ \nabla_{\mathbf{w}}J(\mathbf{w}) = -2\mathbb{E}\bigg[(V^{\pi}(s)-V(s, \mathbf{w}))\cdot\phi(s)\bigg]$</p>
					<p>Т.к. значения функции полезности на практике неизвестны, ее заменяют на:</p>
					<ul>
						<li>Для MC — отдача $G_t$;</li>
						<li>Для TD — показатель $r_{t+1}+\gamma \hat{V}(s_{t+1}, \mathbf{w})$.</li>
					</ul>
				</div>
			</div>
		</div>
	</body>
	<script type="text/javascript" src="../../../js/katex.js"></script>
	<script type="text/javascript" src="../../../js/contrib/auto-render.js"></script>
	<script type="text/javascript" src="../../../js/render.js"></script>
	<script type="text/javascript" src="../../../js/display.js"></script>
	<script type="text/javascript" src="../../../js/navigate.js"></script>
</html>