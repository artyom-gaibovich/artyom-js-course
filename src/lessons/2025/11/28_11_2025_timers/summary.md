## **1) Мини-задания**

1. Создайте таймер, который выводит `"Hello"` через 3 секунды.
2. Создайте таймер, который передаёт два аргумента и выводит их.
3. Напишите код, который выводит:

   ```
   A
   C
   B
   ```

   используя таймер на 1 секунду.
4. Создайте таймер и отмените его до выполнения.
5. Передайте массив аргументов через spread (`...args`) в `setTimeout`.


6. Объясните порядок выполнения:

```js
setTimeout(() => console.log("X"), 0);
console.log("Y");
```

7. Что выведется?

```js
console.log(1);

setTimeout(() => console.log(2), 500);

for (let i = 0; i < 2e8; i++) {} 

console.log(3);
```

8. Создайте код, где один таймер задерживает другой, и объясните почему.

9. Напишите свой “пошаговый разбор” примера:

```js
console.log(1);
setTimeout(() => console.log(2), 1000);
console.log(3);
```

10. Нарисуйте на бумаге схему Call Stack → Web API → Callback Queue → Event Loop.



---

## **2) Контрольные вопросы**

1. Является ли `setTimeout` частью JavaScript?
2. В каких единицах времени измеряется задержка таймера?
3. Что возвращает `setTimeout`?
4. Как отменить таймер?
5. Выполнится ли код сразу после `setTimeout`?
6. Что произойдёт, если вызвать `setTimeout` с задержкой `0`?
7. Где используются таймеры на практике?
8. Что такое Event Loop?
9. Зачем нужен Callback Queue?
10. Где выполняются таймеры: в JS или в Web API?
11. Что делает setTimeout после вызова?
12. Когда callback попадает обратно в стек?
13. Почему JavaScript остаётся однопоточным, но умеет выполнять асинхронный код?
14. Что произойдёт, если стек занят в момент, когда таймер “сработал”?

---

## **3) Краткое резюме**

* `setTimeout` — это API браузера/Node.js, а не часть языка.
* Позволяет **отложить выполнение** функции на заданный период.
* Поддерживает передачу аргументов.
* Не блокирует выполнение кода.
* Возвращает числовой ID.
* `clearTimeout` отменяет таймер.
* Таймер выполняется **один раз**.
* Для повторяющихся действий используется `setInterval`.
* JavaScript работает однопоточно, но среда окружения предоставляет Web API.
* Таймеры (`setTimeout`) работают **в Web API**, а не внутри JS.
* callback возвращается в **Callback Queue** после окончания задержки.
* Event Loop переносит callback в стек, когда стек свободен.
* Поэтому код с таймерами выполняется **не сразу**, и иногда — **не в точное время**.

---
